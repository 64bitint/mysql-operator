// Copyright (c) 2022, Oracle and/or its affiliates.
//
// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl/
//

pipeline {
	agent {
		node {
			label 'operator-ci'
		}
	}
	parameters {
		string(name: 'OPERATOR_GIT_REVISION', defaultValue: 'dirty-myf-267-setup-jenkins-pipeline', description: 'a git revision or branch to run against')
		string(name: 'OPERATOR_IMAGE', defaultValue: 'mysql-operator:8.0.29-2.0.4', description: 'an image related to the aforementioned git revision')
		booleanParam(name: 'OPERATOR_INTERNAL_BUILD', defaultValue: false, description: 'triggered by us (e.g. by a push to a dev branch) or externally (e.g. from the concourse)')
	}
	environment {
		WORKERS_FOLDER = 'Shell/KubernetesOperator/sandbox'
		BUILD_TRIGGERED_BY = "${env.OPERATOR_INTERNAL_BUILD ? 'internal' : 'concourse'}"
		LOG_SUBDIR = "build-${BUILD_NUMBER}"
		LOG_DIR = "${WORKSPACE}/${LOG_SUBDIR}"
		ARTIFACT_FILENAME = "result-${JOB_BASE_NAME}-${BUILD_NUMBER}.tar.bz2"
		ARTIFACT_PATH = "${WORKSPACE}/${ARTIFACT_FILENAME}"
		SLACK_CHANNEL = '#mysql-operator-ci'
		BUILD_NOTIFICATION_HEADER = "${currentBuild.fullDisplayName} (<${env.BUILD_URL}|Open>)"
	}
 	options {
		timeout(time: 2, unit: 'HOURS')
		timestamps()
		copyArtifactPermission("${env.WORKERS_FOLDER}/k3d,${env.WORKERS_FOLDER}/minikube")
	}
	stages {
		stage('init') {
			steps {
				script {
					env.GIT_AUTHOR_DATE = sh (script: "git log -1 --pretty='%an <%ae>, %cd' ${GIT_COMMIT}", returnStdout: true).trim()
					env.GIT_COMMIT_SUBJECT = sh (script: "git log -1 --pretty=%s ${GIT_COMMIT}", returnStdout: true).trim()
				}

				slackSend channel: "${env.SLACK_CHANNEL}",
					sendAsText: true,
					message: """${env.BUILD_NOTIFICATION_HEADER}
${currentBuild.getBuildCauses().shortDescription} (${env.BUILD_TRIGGERED_BY})
Revision: ${env.OPERATOR_GIT_REVISION}
Image: ${env.OPERATOR_IMAGE}
The latest commit:
${env.GIT_COMMIT}
${env.GIT_AUTHOR_DATE}
${env.GIT_COMMIT_SUBJECT}"""

				sh 'mkdir -p ${LOG_DIR}'

				build job: "${env.WORKERS_FOLDER}/test-init", parameters: [
					string(name: 'OPERATOR_GIT_REVISION', value: params.OPERATOR_GIT_REVISION),
					string(name: 'OPERATOR_IMAGE', value: params.OPERATOR_IMAGE),
					booleanParam(name: 'OPERATOR_INTERNAL_BUILD', value: params.OPERATOR_INTERNAL_BUILD)]
			}
		}
		stage('test') {
			parallel {
				stage('minikube') {
					steps {
						echo "minikube"
						build job: "${env.WORKERS_FOLDER}/minikube", parameters: [
							string(name: 'OPERATOR_GIT_REVISION', value: params.OPERATOR_GIT_REVISION),
							string(name: 'OPERATOR_IMAGE', value: params.OPERATOR_IMAGE),
							booleanParam(name: 'OPERATOR_INTERNAL_BUILD', value: params.OPERATOR_INTERNAL_BUILD)
						]
					}
					post {
						always {
							echo "minikube results"
							copyArtifacts fingerprintArtifacts: true,
								projectName: "${env.WORKERS_FOLDER}/minikube",
								selector: lastCompleted(),
								target: "${LOG_SUBDIR}"
						}
						cleanup {
							script {
								if (addTestResults("minikube")) {
									env.MINIKUBE_RESULTS_AVAILABLE = true
								}
							}
						}
					}
				}
				stage('k3d') {
					// with agent set, some files will be stored in $WORKSPACE_TMP
					// agent {
					// 	label "operator-ci"
					// }
					steps {
						echo "k3d"

						// sleep 300
						sleep 60
						build job: "${env.WORKERS_FOLDER}/k3d", parameters: [
							string(name: 'OPERATOR_GIT_REVISION', value: params.OPERATOR_GIT_REVISION),
							string(name: 'OPERATOR_IMAGE', value: params.OPERATOR_IMAGE),
							booleanParam(name: 'OPERATOR_INTERNAL_BUILD', value: params.OPERATOR_INTERNAL_BUILD)
						]
					}
					post {
						always {
							echo "k3d post"
							copyArtifacts fingerprintArtifacts: true,
								projectName: "${env.WORKERS_FOLDER}/k3d",
								selector: lastCompleted(),
								target: "${LOG_SUBDIR}"
						}
						cleanup {
							script {
								if (addTestResults("k3d")) {
									env.K3D_RESULTS_AVAILABLE = true
								}
							}
						}
					}
				}
			}
			post {
				always {
					slackSend channel: "${env.SLACK_CHANNEL}",
						color: "good",
						message: "##################### post test"

					script {
						sh 'ls ${LOG_DIR}'
						env.TESTS_STATUS_HEADER = "Test suite:"
						if (env.MINIKUBE_RESULTS_AVAILABLE || env.K3D_RESULTS_AVAILABLE) {
							if (!env.MINIKUBE_RESULTS_AVAILABLE) {
								env.TESTS_STATUS_HEADER += "\nNo test results for minikube!"
							}
							if (!env.K3D_RESULTS_AVAILABLE) {
								env.TESTS_STATUS_HEADER += "\nNo test results for k3d!"
							}
						} else {
							env.TESTS_STATUS_HEADER = "\nNo test results available!"
						}
					}
				}
				changed {
					// script {
					// 	modifyBuildStatus("changed")
					// }
					// echo 'changed'
					slackSend channel: "${env.SLACK_CHANNEL}",
							color: 'good',
							message: "post tests changed"
				}
				fixed {
					// script {
					// 	modifyBuildStatus("fixed")
					// }
					// echo "fixed"
					slackSend channel: "${env.SLACK_CHANNEL}",
							color: 'good',
							message: "post tests fixed."
				}
				unstable {
					// script {
					// 	modifyBuildStatus("unstable")
					// }
					// echo 'unstable'
					slackSend channel: "${env.SLACK_CHANNEL}",
							color: 'warning',
							message: "post tests unstable."
				}
				regression {
					// script {
					// 	modifyBuildStatus("regression")
					// }
					// echo "regression"
					slackSend channel: "${env.SLACK_CHANNEL}",
							color: 'warning',
							message: "post tests regression."
				}
				failure {
					// script {
					// 	modifyBuildStatus("failure")
					// }
					// echo 'failed'
					slackSend channel: "${env.SLACK_CHANNEL}",
							color: 'danger',
							message: "post tests failed."
				}
				aborted {
					// script {
					// 	modifyBuildStatus("aborted")
					// }
					// echo "aborted"
					slackSend channel: "${env.SLACK_CHANNEL}",
							color: 'warning',
							message: "post tests aborted."
				}
				unsuccessful {
					// script {
					// 	modifyBuildStatus("unsuccessful")
					// }
					// echo "unsuccessful"
					slackSend channel: "${env.SLACK_CHANNEL}",
							color: 'danger',
							message: "post tests unsuccessful."
				}
				success {
					// script {
					// 	modifyBuildStatus("success")
					// }
					// echo 'succeeded'
					// slackSend channel: "${env.SLACK_CHANNEL}", message: "post tests Build Started - ${env.JOB_NAME} ${env.BUILD_NUMBER} (<${env.BUILD_URL}|Open>)"
					slackSend channel: "${env.SLACK_CHANNEL}",
							color: 'good',
							message: "post tests success ."
				}
		// 		cleanup {
		// 		}
			}
		}
	}
	post {
		always {
			slackSend channel: "${env.SLACK_CHANNEL}",
				color: "good",
				message: "##################### post build"

			script {
				env.BUILD_DURATION = "${currentBuild.durationString.minus(' and counting')}"
				env.CHANGE_LOG = getChangeLog()

				sh 'ls ${LOG_DIR}'
				if (env.MINIKUBE_RESULTS_AVAILABLE || env.K3D_RESULTS_AVAILABLE) {
					sh "cd ${LOG_DIR} && tar cvjf ${ARTIFACT_PATH} *"
					archiveArtifacts artifacts: "${ARTIFACT_FILENAME}", fingerprint: true
				}
			}
		}
		changed {
			script {
				modifyBuildStatus("changed")
			}
		}
		fixed {
			script {
				modifyBuildStatus("fixed")
			}
		}
		unstable {
			script {
				modifyBuildStatus("unstable")
			}
		}
		regression {
			script {
				modifyBuildStatus("regression")
			}
		}
		failure {
			script {
				modifyBuildStatus("failure")
			}
		}
		aborted {
			script {
				modifyBuildStatus("aborted")
			}
		}
		unsuccessful {
			script {
				modifyBuildStatus("unsuccessful")
			}
		}
		success {
			script {
				modifyBuildStatus("success")
			}
		}
		cleanup {
			slackSend channel: "${env.SLACK_CHANNEL}",
				sendAsText: true,
				color: "good",
					message: """${env.BUILD_NOTIFICATION_HEADER}
Status: ${env.BUILD_STATUS}
Duration: ${env.BUILD_DURATION}
${env.CHANGE_LOG}
${env.TESTS_STATUS_HEADER}"""
		}
	}
}

@NonCPS
def addTestResults(String k8s_env) {
	sh "ls ${env.LOG_DIR}"
	def testResults = findFiles glob: "**/${env.LOG_SUBDIR}/result-$k8s_env-*.tar.bz2"
	if (testResults.length == 0) {
		return false
	}

	def resultPattern = "${env.LOG_DIR}/result-$k8s_env-*.tar.bz2"
	sh "cat ${resultPattern} | tar jxvf - -i -C ${env.LOG_DIR} && rm $resultPattern"

	// useful during refactorings
	sh "touch ${LOG_DIR}/xml/*.xml"

	def summary = junit allowEmptyResults: true, testResults: "${env.LOG_SUBDIR}/xml/*.xml"
	echo "${summary.totalCount} tests, ${summary.passCount} passed, ${summary.failCount} failures, ${summary.skipCount} skipped"
	return true
}

@NonCPS
def getChangeLog() {
	def changeSets = currentBuild.changeSets
	if (!changeSets.size()) {
		return "No changes\n"
	}

	def changeLog = "Changes:\n"
	for (int i = 0; i < changeSets.size(); ++i) {
		def entries = changeSets[i].items
		for (int j = 0; j < entries.length; ++j) {
			def entry = entries[j]
			changeLog += "${entry.msg} [${entry.author}, ${new Date(entry.timestamp)}]\n"
		}
	}
	return changeLog
}

@NonCPS
def modifyBuildStatus(String status) {
	if (!env.BUILD_STATUS) {
		env.BUILD_STATUS = status
	} else {
		env.BUILD_STATUS += ", " + status
	}
}
